# RepoRoller REST API

[![Rust](https://img.shields.io/badge/rust-1.90%2B-orange.svg)](https://www.rust-lang.org/)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](../../LICENSE)

A production-ready REST API for automated GitHub repository creation with organization-specific configuration management.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Quick Start](#quick-start)
- [API Documentation](#api-documentation)
- [Design Principles](#design-principles)
- [Architecture](#architecture)
- [API Endpoints](#api-endpoints)
- [Authentication](#authentication--authorization)
- [Error Handling](#error-handling)
- [Deployment](#deployment)
- [Development](#development)
- [Testing](#testing)
- [Contributing](#contributing)
- [License](#license)

## Overview

The RepoRoller REST API provides a comprehensive HTTP interface for automated GitHub repository creation with organization-specific configuration management. Built with Axum, it follows RESTful principles and supports JSON request/response formats.

**Version**: v1
**Base URL**: `/api/v1`
**Authentication**: GitHub App installation tokens (Bearer token)
**Framework**: Axum 0.7 on Tokio async runtime

## Features

- **Repository Management**: Create repositories with template-based configuration
- **Template Discovery**: Automatic discovery of templates via GitHub topic search
- **Organization Settings**: Four-level configuration hierarchy (Template > Team > Type > Global)
- **Validation Endpoints**: Comprehensive validation before repository creation
- **GitHub App Authentication**: Secure token-based authentication with GitHub API
- **Request Tracing**: UUID-based request correlation for observability
- **Production Ready**: Docker containerization, health checks, graceful shutdown
- **Comprehensive Error Handling**: Domain error mapping to HTTP status codes
- **Type Safety**: Rust type system with translation layer for HTTP ↔ Domain types

## Quick Start

### Prerequisites

- Rust 1.90 or later
- GitHub App with installation token
- Access to organization metadata repository

### Building

```bash
# Build the API server
cargo build --release --package repo_roller_api

# Or using the build script
./crates/repo_roller_api/scripts/build-api.sh
```

### Running Locally

```bash
# Set environment variables
export GITHUB_TOKEN="ghs_your_installation_token_here"
export PORT=3000  # Optional, defaults to 3000
export RUST_LOG=info  # Optional, defaults to info
export METADATA_REPOSITORY_NAME=".reporoller"  # Optional

# Run the server
cargo run --package repo_roller_api

# Or run the binary directly
./target/release/repo_roller_api
```

The API will be available at `http://localhost:3000/api/v1`

### Using Docker

```bash
# Build the Docker image
docker build -t repo-roller-api -f crates/repo_roller_api/Dockerfile .

# Run the container
docker run -p 3000:3000 \
  -e RUST_LOG=info \
  -e METADATA_REPOSITORY_NAME=".reporoller" \
  repo-roller-api
```

### Example Request

```bash
# Create a repository
curl -X POST http://localhost:3000/api/v1/repositories \
  -H "Authorization: Bearer ${GITHUB_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-new-repo",
    "organization": "my-org",
    "template": "rust-library",
    "visibility": "private"
  }'
```

## API Documentation

### Interactive Documentation

The API follows OpenAPI/REST conventions. Future enhancements (Task 9.7) will include:

- OpenAPI/Swagger specification generation
- Interactive API explorer (Swagger UI)
- Automatic client SDK generation

For now, see the [API Endpoints](#api-endpoints) section below for detailed endpoint documentation.

### Request Format

All requests:

- Must include `Content-Type: application/json` header
- Must include `Authorization: Bearer <token>` header (except `/health`)
- Use camelCase for JSON field names
- Accept UTF-8 encoded JSON

### Response Format

All responses:

- Return JSON with `Content-Type: application/json`
- Use camelCase for JSON field names
- Include appropriate HTTP status codes
- Contain either data or error information

### Request Tracing

Every request is automatically assigned a unique request ID (UUID v4):

- Generated by the `tracing_middleware`
- Logged at request start and completion
- Used for correlation across distributed systems
- Currently logged only (future: add `x-request-id` response header - Task 9.7)

Example log output:

```
[INFO] Request started: request_id=f47ac10b-58cc method=POST uri=/api/v1/repositories
[INFO] Request completed: request_id=f47ac10b-58cc status=201
```

## Design Principles

### 1. **Interface-First Development**

All API types are defined based on specifications in `specs/interfaces/`:

- `api-request-types.md` - Request payload structures
- `api-response-types.md` - Response payload structures
- `api-error-handling.md` - Error response formats

This ensures consistency between specification and implementation.

### 2. **Separation of Concerns**

**Clear Layer Boundaries**:

```
HTTP Layer (API)
    ↓ (translation)
Domain Layer (Core)
    ↓ (orchestration)
Service Layer (Config/GitHub/Template)
```

- **HTTP Layer** (`repo_roller_api`): Request/response handling, validation, authentication
- **Domain Layer** (`repo_roller_core`): Business logic, orchestration
- **Service Layer** (`config_manager`, `github_client`, `template_engine`): Specialized operations

### 3. **Type Safety with Translation**

**Translation Pattern** (`src/translation.rs`):

- HTTP types (camelCase JSON) ↔ Domain types (snake_case Rust)
- Automatic validation during translation
- Clear error propagation with context

```rust
// HTTP → Domain translation with validation
fn http_create_repository_request_to_domain(
    http: CreateRepositoryRequest
) -> Result<RepositoryCreationRequest, ApiError>

// Domain → HTTP translation
fn domain_repository_creation_result_to_http(
    domain: RepositoryCreationResult,
    request: &CreateRepositoryRequest
) -> CreateRepositoryResponse
```

### 4. **Comprehensive Error Handling**

**Error Conversion Chain**:

```
Domain Errors (RepoRollerError)
    ↓ (automatic From trait)
HTTP Errors (ApiError)
    ↓ (IntoResponse trait)
HTTP Status Codes + JSON
```

Every domain error maps to appropriate HTTP status:

- `ValidationError` → 400 Bad Request
- `AuthenticationError` → 401 Unauthorized
- `ConfigurationError` → 400/403/404/500
- `GitHubError` → 502/401/429/404/403
- `RepositoryError` → 409/404/500/408
- And more...

### 5. **Authentication Middleware**

**Two-Layer Authentication**:

1. **Token Validation** (`src/middleware.rs`):
   - Extracts Bearer token from Authorization header
   - Validates token format (10-500 chars, alphanumeric + `_` `-` `.`)
   - Calls GitHub API to verify token and extract organization
   - Creates `AuthContext` for downstream handlers

2. **Per-Request Services** (`src/handlers.rs`):
   - Each handler creates authenticated service instances
   - Uses validated token from `AuthContext`
   - Ensures proper authentication isolation

### 6. **Request Tracing**

**Correlation ID Pattern**:

- Every request gets a unique UUID (`x-request-id` header)
- Logged at entry point for request tracking
- Enables distributed tracing and debugging
- Helps correlate logs across services

## Architecture

### Module Organization

```
repo_roller_api/
├── src/
│   ├── lib.rs              # Crate root, module exports
│   ├── server.rs           # Server setup, middleware stack
│   ├── routes.rs           # Route definitions
│   ├── handlers.rs         # Request handlers (business logic)
│   ├── middleware.rs       # Auth and tracing middleware
│   ├── translation.rs      # HTTP ↔ Domain translation
│   ├── errors.rs           # Error types and conversions
│   └── models/
│       ├── request.rs      # HTTP request types
│       └── response.rs     # HTTP response types
├── Dockerfile              # Container image definition
└── scripts/
    └── build-api.sh        # Build script
```

### Middleware Stack

**Execution Order** (outer → inner):

```
1. CORS Layer               # Cross-origin resource sharing
2. TraceLayer              # Request/response logging
3. TimeoutLayer (30s)      # Request timeout
4. RequestIdLayer          # UUID generation
5. AuthenticationLayer     # Token validation
6. Routes                  # Handler execution
```

### Application State

**Shared State** (`AppState`):

```rust
pub struct AppState {
    pub metadata_repository_name: String,  // Configurable metadata repo
}
```

- Shared across all requests via `axum::extract::State`
- Immutable configuration loaded at startup
- Services created per-request for authentication isolation

## API Endpoints

### Repository Management

#### `POST /api/v1/repositories`

**Create New Repository**

Creates a repository with optional template-based configuration and organization settings.

**Content Strategies**:

RepoRoller supports three content strategies:

1. **Template** (default): Create from a template repository with variable substitution
2. **Empty**: Create an empty repository with only organization defaults
3. **Custom Init**: Create with just README.md and/or .gitignore

See [Empty Repositories Guide](../repo_roller_cli/EMPTY_REPOSITORIES.md) for detailed documentation on non-template creation.

**Request (Template-based)**:

```json
{
  "name": "my-new-repo",
  "organization": "my-org",
  "template": "rust-library",
  "description": "My new repository",
  "visibility": "private",
  "repositoryType": "library",
  "variables": {
    "project_name": "my_project",
    "author": "John Doe"
  },
  "team": "platform"
}
```

**Request (Empty Repository)**:

```json
{
  "name": "my-empty-repo",
  "organization": "my-org",
  "contentStrategy": "empty",
  "description": "Empty repository for code import",
  "visibility": "private",
  "repositoryType": "library",
  "team": "platform"
}
```

**Request (Custom Initialization)**:

```json
{
  "name": "my-init-repo",
  "organization": "my-org",
  "contentStrategy": "custom_init",
  "initializeReadme": true,
  "initializeGitignore": true,
  "description": "Repository with README and .gitignore",
  "visibility": "private",
  "repositoryType": "library"
}
```

**Response** (201 Created):

```json
{
  "repository": {
    "name": "my-new-repo",
    "fullName": "my-org/my-new-repo",
    "url": "https://github.com/my-org/my-new-repo",
    "visibility": "private"
  },
  "appliedConfiguration": {
    "features": { /* repository settings */ },
    "branchProtection": { /* protection rules */ },
    "labels": [ /* configured labels */ ]
  }
}
```

**Request Fields**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Repository name |
| `organization` | string | Yes | Organization name |
| `contentStrategy` | string | No | `"template"` (default), `"empty"`, or `"custom_init"` |
| `template` | string | Conditional | Required for `"template"` strategy |
| `initializeReadme` | boolean | No | Create README.md (only with `"custom_init"`) |
| `initializeGitignore` | boolean | No | Create .gitignore (only with `"custom_init"`) |
| `description` | string | No | Repository description |
| `visibility` | string | No | `"private"` (default) or `"public"` |
| `repositoryType` | string | No | Repository type for configuration |
| `team` | string | No | Team configuration |
| `variables` | object | No | Template variables (only with `"template"`) |

**Implementation Details**:

- Validates request via `http_create_repository_request_to_domain()`
- Determines content provider based on `contentStrategy`
- Creates authenticated GitHub client using installation token
- Calls `repo_roller_core::create_repository()` for orchestration
- Translates domain result to HTTP response
- Handles all error scenarios with appropriate status codes

#### `POST /api/v1/repositories/validate-name`

**Validate Repository Name**

Checks if a repository name follows GitHub naming rules.

**Request**:

```json
{
  "organization": "my-org",
  "name": "my-repo-123"
}
```

**Response** (200 OK):

```json
{
  "valid": true,
  "available": true,  // Future: Check GitHub availability
  "messages": null
}
```

**Validation Rules**:

- Length: 1-100 characters
- Characters: lowercase letters, numbers, hyphens, underscores, periods
- Cannot start with period or hyphen
- Cannot be "." or ".."

#### `POST /api/v1/repositories/validate-request`

**Validate Complete Creation Request**

Validates all aspects of a repository creation request.

**Request**: Same as create repository
**Response** (200 OK):

```json
{
  "valid": true,
  "errors": [],
  "warnings": []
}
```

**Validation Checks**:

- Repository name format
- Template existence (when integrated)
- Variable completeness (when integrated)
- Team existence (when integrated)
- Visibility values ("public" or "private")

### Template Discovery

#### `GET /api/v1/orgs/{org}/templates`

**List Available Templates**

Discovers template repositories by GitHub topic search.

**Response** (200 OK):

```json
{
  "templates": [
    {
      "name": "rust-library",
      "description": "Rust library template with CI/CD",
      "category": "rust"
    }
  ]
}
```

**Implementation**:

- Calls `MetadataRepositoryProvider.list_templates()`
- Searches GitHub for repos with "reporoller-template" topic
- Loads `.reporoller/template.toml` for each template
- Returns summary with name, description, category

#### `GET /api/v1/orgs/{org}/templates/{template}`

**Get Template Details**

Loads complete template configuration.

**Response** (200 OK):

```json
{
  "name": "rust-library",
  "description": "Rust library template",
  "variables": {
    "project_name": {
      "description": "Project name",
      "required": true,
      "default": null
    }
  },
  "configuration": {
    "repositoryType": {
      "policy": "fixed",
      "value": "library"
    }
  }
}
```

**Implementation**:

- Calls `MetadataRepositoryProvider.load_template_configuration()`
- Fetches `.reporoller/template.toml` from template repository
- Parses TOML into `NewTemplateConfig`
- Translates to HTTP response format

#### `POST /api/v1/orgs/{org}/templates/{template}/validate`

**Validate Template Configuration**

Checks template.toml structure and completeness.

**Response** (200 OK):

```json
{
  "valid": true,
  "errors": [],
  "warnings": []
}
```

**Validation**:

- TOML parsing success
- Required fields present
- Variable definitions valid
- Repository type policy valid

### Organization Settings

#### `GET /api/v1/orgs/{org}/repository-types`

**List Repository Types**

Lists available repository type configurations.

**Response** (200 OK):

```json
{
  "types": [
    {
      "name": "library",
      "description": "Reusable library packages"
    },
    {
      "name": "service",
      "description": "Deployable services"
    }
  ]
}
```

**Implementation**:

- Creates `OrganizationSettingsManager`
- Calls `list_available_repository_types()`
- Returns type names with descriptions

#### `GET /api/v1/orgs/{org}/repository-types/{type}`

**Get Repository Type Configuration**

Retrieves complete configuration for a repository type.

**Response** (200 OK):

```json
{
  "name": "library",
  "configuration": {
    "features": {
      "hasIssues": { "value": true, "overrideAllowed": false },
      "hasWiki": { "value": false, "overrideAllowed": true }
    }
  }
}
```

**Implementation**:

- Loads repository type configuration via settings manager
- Returns full `RepositoryTypeConfig` with override controls

#### `GET /api/v1/orgs/{org}/defaults`

**Get Global Defaults**

Retrieves organization-wide default settings.

**Response** (200 OK):

```json
{
  "features": {
    "hasIssues": { "value": true, "overrideAllowed": true },
    "hasProjects": { "value": false, "overrideAllowed": true }
  },
  "branchProtection": {
    "requirePullRequest": { "value": true, "overrideAllowed": false }
  }
}
```

**Implementation**:

- Loads global defaults from metadata repository
- Returns `GlobalDefaults` structure

#### `POST /api/v1/orgs/{org}/preview`

**Preview Merged Configuration**

Shows final configuration after hierarchy merging.

**Request**:

```json
{
  "template": "rust-library",
  "repositoryType": "library",
  "team": "platform"
}
```

**Response** (200 OK):

```json
{
  "mergedConfiguration": {
    "features": { /* merged settings */ }
  },
  "sources": {
    "features.hasIssues": "repositoryType",
    "features.hasWiki": "template"
  }
}
```

**Hierarchy** (highest to lowest precedence):

1. Template configuration
2. Team configuration
3. Repository type configuration
4. Global defaults

**Implementation**:

- Calls `OrganizationSettingsManager.resolve_configuration()`
- Applies four-level hierarchy merging
- Returns merged config with source attribution

#### `POST /api/v1/orgs/{org}/validate`

**Validate Organization Settings**

Validates metadata repository structure and configurations.

**Response** (200 OK):

```json
{
  "valid": true,
  "errors": [],
  "warnings": [],
  "repositoryFound": true
}
```

**Validation**:

- Metadata repository exists and is accessible
- Global defaults file valid TOML
- All repository type configs valid
- Override policies enforced correctly

### Health Check

#### `GET /health`

**Service Health Check**

Simple endpoint for container orchestration health checks.

**Response** (200 OK):

```json
{
  "status": "healthy"
}
```

## Authentication & Authorization

### GitHub App Authentication

**Token Flow**:

1. Client obtains GitHub App installation token
2. Client includes token in Authorization header:

   ```
   Authorization: Bearer ghs_abc123...
   ```

3. Middleware validates token with GitHub API
4. Handler receives `AuthContext` with validated organization

**Token Validation**:

- Format: `Bearer <token>`
- Length: 10-500 characters
- Characters: alphanumeric + `_` `-` `.`
- Real validation: GitHub API call (`list_installations()`)
- Organization extracted from installation account

**Security**:

- Tokens never logged (security policy)
- Per-request service isolation
- Authentication errors return 401 Unauthorized
- Invalid formats return 401 with helpful error messages

## Error Handling

### Error Response Format

**Standard Error Response**:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid repository name format",
    "details": {
      "field": "name",
      "reason": "Name contains invalid characters"
    }
  }
}
```

### HTTP Status Code Mapping

**Client Errors (4xx)**:

- `400 Bad Request` - Validation errors, invalid input
- `401 Unauthorized` - Missing or invalid authentication token
- `403 Forbidden` - Access denied, override policy violation
- `404 Not Found` - Resource not found (template, repository type, etc.)
- `408 Request Timeout` - Operation timed out
- `409 Conflict` - Resource already exists

**Server Errors (5xx)**:

- `500 Internal Server Error` - Unexpected server error, system failure
- `502 Bad Gateway` - GitHub API failure, external service error

### Error Code Taxonomy

**Validation Errors** (400):

- `VALIDATION_ERROR` - Input validation failure
- `INVALID_NAME` - Name format violation
- `INVALID_TEMPLATE` - Template validation failure
- `MISSING_REQUIRED_FIELD` - Required field not provided
- `INVALID_REPOSITORY_TYPE` - Repository type validation failure

**Authentication Errors** (401):

- `MISSING_TOKEN` - No Authorization header
- `INVALID_TOKEN` - Token format invalid or expired
- `AUTHENTICATION_FAILED` - GitHub token validation failed

**Authorization Errors** (403):

- `ACCESS_DENIED` - Insufficient permissions
- `OVERRIDE_NOT_ALLOWED` - Override policy violation

**Resource Errors** (404):

- `NOT_FOUND` - Resource doesn't exist
- `TEMPLATE_NOT_FOUND` - Template not found
- `REPOSITORY_TYPE_NOT_FOUND` - Repository type not found
- `METADATA_REPOSITORY_NOT_FOUND` - Metadata repository missing

**GitHub Errors** (502):

- `GITHUB_API_ERROR` - GitHub API call failed
- `RATE_LIMIT_EXCEEDED` - GitHub rate limit hit

**System Errors** (500):

- `INTERNAL_ERROR` - Unexpected server error
- `CONFIGURATION_ERROR` - System configuration problem

### Error Context

Errors include rich context for debugging:

- **Field name** - Which field failed validation
- **Reason** - Why the error occurred
- **Expected format** - What was expected (for validation)
- **Actual value** - What was provided (sanitized, no secrets)

## Request/Response Patterns

### Naming Conventions

**JSON (camelCase)**:

```json
{
  "repositoryType": "library",
  "hasIssues": true,
  "branchProtection": { }
}
```

**Rust (snake_case)**:

```rust
struct DomainType {
    repository_type: String,
    has_issues: bool,
    branch_protection: BranchProtection,
}
```

**Automatic Translation**:

- Serde handles camelCase ↔ snake_case
- Translation layer validates and converts
- Type safety enforced at compile time

### Request Validation

**Two-Stage Validation**:

1. **HTTP Layer** (format validation):
   - JSON deserialization
   - Required fields present
   - Type correctness
   - Basic format rules

2. **Domain Layer** (business validation):
   - Name format compliance
   - Template existence
   - Variable completeness
   - Override policy enforcement
   - GitHub naming rules

### Idempotency

**Repository Creation**:

- Not idempotent by design
- Each call creates a new repository
- Client responsible for deduplication

**Validation Endpoints**:

- Idempotent (no side effects)
- Safe to call multiple times
- Useful for form validation

### Pagination

**Current**: Not implemented (MVP)

**Future Enhancement**:

- List endpoints will support pagination
- Query parameters: `page`, `per_page`, `sort`
- Response headers: `Link` (rel: next, prev, first, last)
- Total count in response

## Performance Considerations

### Per-Request Service Creation

**Pattern**:

```rust
// Each handler creates its own services
let settings_manager = create_settings_manager(
    &auth.token,
    &auth.organization,
    &state.metadata_repository_name
).await?;
```

**Why**:

- Authentication isolation
- No shared mutable state
- Simpler concurrency model
- Clear authentication boundaries

**Trade-off**:

- GitHub API calls per request
- Potential for caching in future

### Request Timeout

**Default**: 30 seconds

Prevents long-running requests from blocking resources.

**Applies to**:

- Repository creation (template fetch, git operations)
- Configuration loading (GitHub API calls)
- Validation operations

### Caching Strategy (Future)

**Planned Caching**:

- Template configurations (TTL: 5 minutes)
- Global defaults (TTL: 5 minutes)
- Repository type configs (TTL: 5 minutes)
- Organization validation (TTL: 1 minute)

**Cache Invalidation**:

- Webhook on metadata repository changes
- Manual cache clear endpoint (admin only)

## Deployment

### Container Image

**Dockerfile** (Multi-stage build):

```dockerfile
# Stage 1: Build Rust application
FROM rust:1.90 AS builder
# ... build process ...

# Stage 2: Minimal runtime image
FROM alpine:3.20
# ... runtime setup ...
```

**Image Size**: ~100MB (Alpine-based, musl libc)

### Configuration

**Environment Variables**:

- `PORT` - HTTP server port (default: 3000)
- `RUST_LOG` - Logging level (info, debug, trace)
- `METADATA_REPOSITORY_NAME` - Metadata repo name (default: ".reporoller")

**Health Check**:

```
GET /health
Expected: 200 OK with {"status": "healthy"}
```

### Azure Container Instances

**Deployment Pattern**:

1. Build Docker image
2. Push to GitHub Container Registry (GHCR)
3. Deploy to Azure Container Instances
4. Configure with environment variables
5. Expose port 3000 (or configured PORT)

**Resource Recommendations**:

- CPU: 1 core
- Memory: 1GB
- Scaling: Horizontal (multiple instances)

## Testing Strategy

### Unit Tests

**Test Organization**:

- `*_tests.rs` files alongside source
- Test request/response serialization
- Test error conversion
- Test translation functions
- Test validation logic

**Coverage**:

- Request type serialization: ✅
- Response type serialization: ✅
- Error conversions: ✅
- Translation functions: ✅
- Middleware: ✅
- Routes: ✅

### Integration Tests

**Location**: `crates/integration_tests/tests/rest_api_endpoints.rs`

**Test Categories**:

1. **Organization Settings** (10 tests):
   - List repository types
   - Get repository type config
   - Get global defaults
   - Preview configuration
   - Validate organization
   - Complete workflow

2. **Template Discovery** (6 tests):
   - List templates
   - Get template details (success, not found)
   - Validate template (success, not found)

3. **Repository Validation** (3 tests):
   - Validate repository name (valid, invalid)
   - Validate repository request

4. **Authentication** (3 tests):
   - Missing token
   - Invalid token
   - Malformed header

5. **End-to-End Workflows** (1 test):
   - Complete repository creation dry-run (6 steps)

**Total**: 21 integration tests

**Execution**:

- All tests marked `#[ignore]`
- Require real GitHub App credentials
- Use test metadata repository
- Run with: `cargo test --test rest_api_endpoints -- --ignored`

### Test Data

**Test Metadata Repository**: `glitchgrove/.reporoller-test`

**Structure**:

```
.reporoller-test/
├── global-defaults.toml
├── types/
│   ├── library.toml
│   └── service.toml
└── teams/
    └── platform.toml
```

**Environment Variables**:

- `GITHUB_TOKEN` - GitHub App installation token
- `TEST_ORG` - Test organization name
- `TEST_TEMPLATE` - Test template name
- `TEST_REPOSITORY_TYPE` - Test repository type
- `TEST_TEAM` - Test team name
- `TEST_ORG_NO_METADATA` - Organization without metadata repo

## Security Considerations

### Token Handling

**Never Log Tokens**:

```rust
// ❌ NEVER DO THIS
tracing::info!("Token: {}", token);

// ✅ CORRECT
tracing::info!("Token validated successfully (redacted)");
```

**Token Storage**:

- Tokens live only in request scope
- Not persisted to disk
- Not cached
- Passed via secure HTTPS only

### Input Validation

**Defense in Depth**:

1. JSON deserialization (type safety)
2. Format validation (naming rules)
3. Business validation (domain rules)
4. GitHub API validation (resource existence)

**Sanitization**:

- All user input validated before use
- Path traversal prevention
- Injection attack prevention
- Safe error messages (no token leakage)

### CORS Configuration

**Current** (Development):

```rust
CorsLayer::new()
    .allow_origin(Any)  // ⚠️ Permissive for development
    .allow_methods([GET, POST, PUT, DELETE, OPTIONS])
```

**Production Recommendation**:

```rust
CorsLayer::new()
    .allow_origin("https://app.example.com")  // Specific origin
    .allow_methods([GET, POST])  // Minimal methods
    .allow_credentials(true)
```

### Rate Limiting (Future)

**Planned**:

- Per-IP rate limiting
- Per-organization rate limiting
- GitHub API rate limit awareness
- Backoff and retry logic

## Monitoring & Observability

### Structured Logging

**Log Levels**:

- `ERROR` - Errors requiring attention
- `WARN` - Warnings, degraded functionality
- `INFO` - Request/response logging, key operations
- `DEBUG` - Detailed operation flow
- `TRACE` - Very detailed debugging

**Request Tracing**:

```
[INFO] Request received: id=f47ac10b-58cc-4372-a567-0e02b2c3d479 method=POST path=/api/v1/repositories
[INFO] Repository creation started: name=my-repo org=my-org
[INFO] Configuration resolved: template=rust-library type=library
[INFO] Repository created successfully: url=https://github.com/my-org/my-repo
[INFO] Response sent: status=201 duration=2.3s
```

### Metrics (Future)

**Planned Metrics**:

- Request rate (per endpoint)
- Response time (p50, p95, p99)
- Error rate (by type)
- Authentication success/failure
- GitHub API call count
- Configuration cache hit rate

### Health Monitoring

**Health Endpoint**: `GET /health`

**Future Enhancements**:

- `/health/ready` - Readiness probe
- `/health/live` - Liveness probe
- Dependency health checks (GitHub API, metadata repo)

## Future Enhancements

### Phase 2 Features

1. **Pagination**:
   - List endpoints return paged results
   - Configurable page size
   - Cursor-based pagination

2. **Filtering & Search**:
   - Filter templates by category
   - Search templates by keyword
   - Filter repository types

3. **Batch Operations**:
   - Create multiple repositories
   - Bulk validation
   - Async job processing

4. **Webhooks**:
   - Notify on repository creation
   - Configuration change notifications
   - Template updates

5. **Advanced Authorization**:
   - Role-based access control
   - Team-based permissions
   - Admin endpoints

6. **Caching & Performance**:
   - Redis cache for configurations
   - ETags for conditional requests
   - Response compression

7. **API Versioning**:
   - `/api/v2` when breaking changes needed
   - Version negotiation via headers
   - Deprecation warnings

### MCP Server (Post-MVP)

**Model Context Protocol**:

- AI/LLM integration
- Natural language repository creation
- Intelligent template selection
- Configuration recommendations

**Separate Implementation**: Task 11.0+

## Development

### Project Structure

```
crates/repo_roller_api/
├── src/
│   ├── lib.rs              # Crate root and exports
│   ├── server.rs           # Server configuration
│   ├── routes.rs           # Route definitions
│   ├── handlers.rs         # Request handlers
│   ├── middleware.rs       # Auth and tracing middleware
│   ├── translation.rs      # HTTP ↔ Domain translation
│   ├── errors.rs           # Error types and conversions
│   ├── models/
│   │   ├── request.rs      # HTTP request types
│   │   └── response.rs     # HTTP response types
│   └── *_tests.rs          # Unit tests
├── Dockerfile              # Container image definition
├── scripts/
│   └── build-api.sh        # Build script
└── README.md               # This file
```

### Adding New Endpoints

1. **Define Request/Response Types** (`src/models/`)

   ```rust
   #[derive(Debug, Deserialize)]
   #[serde(rename_all = "camelCase")]
   pub struct MyRequest {
       pub field: String,
   }
   ```

2. **Implement Handler** (`src/handlers.rs`)

   ```rust
   pub async fn my_handler(
       State(state): State<AppState>,
       Extension(auth): Extension<AuthContext>,
       Json(request): Json<MyRequest>,
   ) -> Result<Json<MyResponse>, ApiError> {
       // Implementation
   }
   ```

3. **Add Route** (`src/routes.rs`)

   ```rust
   .route("/my-endpoint", post(handlers::my_handler))
   ```

4. **Write Tests** (`src/handlers_tests.rs` or integration tests)

### Code Style

- Follow Rust API guidelines and Clippy suggestions
- Use `cargo fmt` for formatting
- Document all public APIs with rustdoc comments
- Include examples in doc comments
- Write descriptive error messages

### Running Tests

```bash
# Run all unit tests
cargo test --package repo_roller_api

# Run specific test
cargo test --package repo_roller_api test_name

# Run with logging
RUST_LOG=debug cargo test --package repo_roller_api
```

## Testing

### Unit Tests

Located in `src/*_tests.rs` files:

- **Request/Response Serialization**: Verify JSON ↔ Rust type conversion
- **Error Conversion**: Test domain error → HTTP status mapping
- **Translation Functions**: Test HTTP ↔ Domain type translation
- **Middleware**: Test authentication and tracing logic
- **Validation**: Test input validation rules

**Run**: `cargo test --package repo_roller_api`

### Integration Tests

Located in `crates/integration_tests/tests/rest_api_endpoints.rs`:

- **21 comprehensive tests** covering all endpoint groups
- **Organization Settings** (10 tests): repository types, global defaults, preview, validation
- **Template Discovery** (6 tests): list templates, get details, validate
- **Repository Validation** (3 tests): name validation, request validation
- **Authentication** (3 tests): missing token, invalid token, malformed header
- **End-to-End Workflows** (1 test): complete 6-step repository creation flow

All integration tests are marked `#[ignore]` and require real GitHub infrastructure:

```bash
# Set environment variables
export GITHUB_TOKEN="ghs_your_token"
export TEST_ORG="your-test-org"
export TEST_TEMPLATE="rust-library"
export TEST_REPOSITORY_TYPE="library"
export TEST_TEAM="platform"
export TEST_ORG_NO_METADATA="org-without-metadata"

# Run integration tests
cargo test --package integration_tests --test rest_api_endpoints -- --ignored
```

### Test Coverage

Current coverage:

- ✅ Request type serialization
- ✅ Response type serialization
- ✅ Error conversions (all major variants)
- ✅ Translation functions
- ✅ Authentication middleware
- ✅ Route configuration
- ✅ Integration workflows

## Contributing

### Development Workflow

1. Create a feature branch from `master`
2. Implement changes with tests
3. Run `cargo test` and `cargo clippy`
4. Update documentation
5. Submit pull request

### Commit Guidelines

Follow conventional commits format:

```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

Types: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`

### Code Review

All changes require:

- Passing tests (unit + integration)
- Zero clippy warnings
- Updated documentation
- Code review approval

## License

This project is licensed under the MIT License - see the [LICENSE](../../LICENSE) file for details.

---

## Conclusion

The RepoRoller REST API is designed for:

- **Reliability**: Comprehensive error handling, timeouts, health checks
- **Security**: Token validation, input sanitization, no secret leakage
- **Maintainability**: Clear architecture, separation of concerns, type safety
- **Extensibility**: Modular design, future-proof patterns
- **Observability**: Structured logging, request tracing, monitoring ready

The API is production-ready for MVP with clear paths for future enhancements.

**For questions, issues, or feature requests**, please open an issue on GitHub.
